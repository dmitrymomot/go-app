// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: tokens.sql

package auth_repository

import (
	"context"
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

const cleanUpTokens = `-- name: CleanUpTokens :exec
DELETE FROM tokens WHERE refresh_expires_at < now()
`

// Clean up expired tokens
func (q *Queries) CleanUpTokens(ctx context.Context) error {
	_, err := q.exec(ctx, q.cleanUpTokensStmt, cleanUpTokens)
	return err
}

const deleteTokenByAccessTokenID = `-- name: DeleteTokenByAccessTokenID :exec
DELETE FROM tokens WHERE access_token_id = $1
`

// Delete a token by access token ID
func (q *Queries) DeleteTokenByAccessTokenID(ctx context.Context, accessTokenID uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteTokenByAccessTokenIDStmt, deleteTokenByAccessTokenID, accessTokenID)
	return err
}

const deleteTokenByRefreshTokenID = `-- name: DeleteTokenByRefreshTokenID :exec
DELETE FROM tokens WHERE refresh_token_id = $1
`

// Delete a token by refresh token ID
func (q *Queries) DeleteTokenByRefreshTokenID(ctx context.Context, refreshTokenID uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteTokenByRefreshTokenIDStmt, deleteTokenByRefreshTokenID, refreshTokenID)
	return err
}

const deleteTokensByUserID = `-- name: DeleteTokensByUserID :exec
DELETE FROM tokens WHERE user_id = $1
`

// Delete all tokens for a user
func (q *Queries) DeleteTokensByUserID(ctx context.Context, userID uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteTokensByUserIDStmt, deleteTokensByUserID, userID)
	return err
}

const findTokenByAccessTokenID = `-- name: FindTokenByAccessTokenID :one
SELECT id, user_id, access_token_id, access_expires_at, refresh_token_id, refresh_expires_at, created_at, updated_at, metadata FROM tokens WHERE access_token_id = $1 AND access_expires_at > now()
`

// Find a token by access token ID
func (q *Queries) FindTokenByAccessTokenID(ctx context.Context, accessTokenID uuid.UUID) (Token, error) {
	row := q.queryRow(ctx, q.findTokenByAccessTokenIDStmt, findTokenByAccessTokenID, accessTokenID)
	var i Token
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AccessTokenID,
		&i.AccessExpiresAt,
		&i.RefreshTokenID,
		&i.RefreshExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Metadata,
	)
	return i, err
}

const findTokenByID = `-- name: FindTokenByID :one
SELECT id, user_id, access_token_id, access_expires_at, refresh_token_id, refresh_expires_at, created_at, updated_at, metadata FROM tokens WHERE id = $1 AND refresh_expires_at > now()
`

// Find a token by ID
func (q *Queries) FindTokenByID(ctx context.Context, id uuid.UUID) (Token, error) {
	row := q.queryRow(ctx, q.findTokenByIDStmt, findTokenByID, id)
	var i Token
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AccessTokenID,
		&i.AccessExpiresAt,
		&i.RefreshTokenID,
		&i.RefreshExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Metadata,
	)
	return i, err
}

const findTokenByRefreshTokenID = `-- name: FindTokenByRefreshTokenID :one
SELECT id, user_id, access_token_id, access_expires_at, refresh_token_id, refresh_expires_at, created_at, updated_at, metadata FROM tokens WHERE refresh_token_id = $1 AND refresh_expires_at > now()
`

// Find a token by refresh token ID
func (q *Queries) FindTokenByRefreshTokenID(ctx context.Context, refreshTokenID uuid.UUID) (Token, error) {
	row := q.queryRow(ctx, q.findTokenByRefreshTokenIDStmt, findTokenByRefreshTokenID, refreshTokenID)
	var i Token
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AccessTokenID,
		&i.AccessExpiresAt,
		&i.RefreshTokenID,
		&i.RefreshExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Metadata,
	)
	return i, err
}

const refreshToken = `-- name: RefreshToken :exec
UPDATE tokens SET 
    access_token_id = $1, 
    access_expires_at = $2, 
    refresh_token_id = $3, 
    refresh_expires_at = $4 
WHERE refresh_token_id = $5 AND refresh_expires_at > now()
`

type RefreshTokenParams struct {
	AccessTokenID     uuid.UUID `json:"access_token_id"`
	AccessExpiresAt   time.Time `json:"access_expires_at"`
	RefreshTokenID    uuid.UUID `json:"refresh_token_id"`
	RefreshExpiresAt  time.Time `json:"refresh_expires_at"`
	OldRefreshTokenID uuid.UUID `json:"old_refresh_token_id"`
}

// Refresh a token
func (q *Queries) RefreshToken(ctx context.Context, arg RefreshTokenParams) error {
	_, err := q.exec(ctx, q.refreshTokenStmt, refreshToken,
		arg.AccessTokenID,
		arg.AccessExpiresAt,
		arg.RefreshTokenID,
		arg.RefreshExpiresAt,
		arg.OldRefreshTokenID,
	)
	return err
}

const storeToken = `-- name: StoreToken :exec
INSERT INTO tokens (id, user_id, access_token_id, refresh_token_id, metadata) VALUES (
    $1, $2, $3, $4, $5::json
) RETURNING id, user_id, access_token_id, access_expires_at, refresh_token_id, refresh_expires_at, created_at, updated_at, metadata
`

type StoreTokenParams struct {
	ID             uuid.UUID       `json:"id"`
	UserID         uuid.UUID       `json:"user_id"`
	AccessTokenID  uuid.UUID       `json:"access_token_id"`
	RefreshTokenID uuid.UUID       `json:"refresh_token_id"`
	Metadata       json.RawMessage `json:"metadata"`
}

// Store a token
func (q *Queries) StoreToken(ctx context.Context, arg StoreTokenParams) error {
	_, err := q.exec(ctx, q.storeTokenStmt, storeToken,
		arg.ID,
		arg.UserID,
		arg.AccessTokenID,
		arg.RefreshTokenID,
		arg.Metadata,
	)
	return err
}
